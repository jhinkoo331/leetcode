### 1. 如何提高机试中的AC能力

1. 平时写题目时, 尽可能做到one pass, 提高one pass的方式有:
   1. 仔细审题, 不要理解错误了题意 (吃过好几次这样的亏)
   2. 把题目给的case撸一遍结果, 确定是否正确理解题意, 对题目的思路是否正确
   3. 观察题目给的输入限制, 输入限制涉及到程序的边界, 对边界条件进行思考的测试
2. 上机时由于比较紧张, 很容易陷在当前的思路中出不来, 当思路无法打开时, 把所有常见数据结构过一遍, 看看有哪些能用来做性能优化, 常见数据结构有:
   1. Array, Linked Array, Stack
   2. 单调数组, 单调栈
   3. Moving Window
   4. Map (Ordered, Unordered)
   5. Set
   6. DSU % 并查集
   7. Binary Tree
   8. Trie
   9. Segment Tree
   10. Heap, Priority Queue

### 2. 解题小技巧

* 有些case会测试极端情况, 例如数据具有规律性(单调递减), 通过shuffle打乱输入数据可以避免极端情况的出现
* 如果题目的输入规模很小, 则可以使用复杂度非常高的算法(例如$O(n^3)$), 例如穷举或打一个三维表 (吃过没看输入范围一直想着怎么优化复杂度的亏)
* 打表
  * 打表是一种非常高效, 也非常常用的优化思路, 本质上是空间换时间
  * 如果题目给定的输入范围是$0$ ~ $n$之间, 那么可以直接打表把$f(0)$到$f(n)$的结果全部计算出来, 后续所有的计算都直接从表中拿数据, 因为test case中一定会包含$n$的测试用例
  * 打表的数据需要放在全局静态变量中**(todo: 类静态变量还不清楚o不ok)**, leetcode的执行方式是对每个case生成一个新的solution对象, 全局静态变量不会在不同的case之间被重置
  * 打表可以跟粗暴一些, 直接上元编程思想, 把表输出位string, 然后粘贴到代码里让静态变量成为已初始化的全局变量, 这样做的缺点是编译后的二进制包会比较大 **todo: 加载程序耗时会不会被算入程序耗时?**

